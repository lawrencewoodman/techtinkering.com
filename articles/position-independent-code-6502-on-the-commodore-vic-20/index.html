<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
  <title>Position Independent Code (6502) on the Commodore VIC-20</title>
  <meta name="description" content="If we are writing 6502 machine code and want to to create a routine or program that can be placed in any location then we have to create Position Independent Cod">
  <meta name="keywords" content="Retro Vintage Programming Tinkering"/>

  <!-- *** Twitter Card *** -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@techtinkering">
  <meta name="twitter:title" content="Position Independent Code (6502) on the Commodore VIC-20">
  <meta name="twitter:description" content="If we are writing 6502 machine code and want to to create a routine or program that can be placed in any location then we have to create Position Independent Cod">
    <meta name="twitter:image"
         content="https://techtinkering.com/img/social_images/6502_pic_make_data_table_assembly.png">
  <!-- *** Twitter Card *** -->

  <!-- *** Open Graph *** --->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Position Independent Code (6502) on the Commodore VIC-20">
  <meta property="og:description" content="If we are writing 6502 machine code and want to to create a routine or program that can be placed in any location then we have to create Position Independent Cod">
  <meta property="og:url" content="https://techtinkering.com/articles/position-independent-code-6502-on-the-commodore-vic-20/">
    <meta property="og:image"
         content="https://techtinkering.com/img/social_images/6502_pic_make_data_table_assembly.png">
  <!-- *** Open Graph *** --->

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-4388762-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-4388762-2');
  </script>

  <script>
    console.log('timeZone: '+Intl.DateTimeFormat().resolvedOptions().timeZone);
    function isUserFromUK() {
      return Intl.DateTimeFormat().resolvedOptions().timeZone == "Europe/London";
    }
  </script>

  <link href="/css/main.css" rel="stylesheet">
  <link href="/css/article.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" rel="stylesheet" type="text/css" />
  <link rel="canonical" href="https://techtinkering.com/articles/position-independent-code-6502-on-the-commodore-vic-20/">
  <link rel="alternate" type="application/rss+xml" title="TechTinkering - Retro Computers, Programming, General Technical Tinkering"
        href="https://feedproxy.google.com/TechTinkering" />

	<!-- ****** faviconit.com favicons ****** -->
	<link rel="shortcut icon" href="/favicon.ico">
	<link rel="icon" sizes="16x16 32x32 64x64" href="/favicon.ico">
	<!-- ****** faviconit.com favicons ****** -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>

  <script>
    if (isUserFromUK()) {
      console.log("No Google ADs - UK user");
    } else {
      console.log("Google ADs - not from uk");
      document.write('<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"><' + '/script>');
    }
  </script>

  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->

  <script>
    // Cookie Consent - https://cookieconsent.insites.com
    window.addEventListener("load", function(){
    window.cookieconsent.initialise({
      "palette": {
        "popup": {
          "background": "#252e39"
        },
        "button": {
          "background": "#14a7d0"
        }
      },
      "theme": "classic",
      "position": "top",
      "static": true,
      "content": {
        "message": "TechTinkering uses cookies for advertising, analytics, etc.",
        "href": "https://techtinkering.com/privacy/"
      }
    })});
  </script>

  <script>
    if (isUserFromUK()) {
      console.log("No Google Ads - uk user");
      console.log("Amazon Banner - from uk");
      // Amazon Prime Video Banner 728x90 and 300x250
      amznBanner='<div class="amazonBannerDesktop"><iframe src="https://rcm-eu.amazon-adsystem.com/e/cm?o=2&p=48&l=ur1&category=piv&banner=0E183RXMV88X6J8GJ002&f=ifr&linkID=a2c37aae0561f075af3356504493bdf0&t=techtinkering-21&tracking_id=techtinkering-21" width="728" height="90" scrolling="no" border="0" marginwidth="0" style="border:none;" frameborder="0" sandbox="allow-scripts allow-same-origin allow-popups allow-top-navigation-by-user-activation"><' + '/iframe><' +'/div><div class="amazonBannerMobile"><iframe src="https://rcm-eu.amazon-adsystem.com/e/cm?o=2&p=12&l=ur1&category=piv&banner=070GKT77WVHAHSRTHK02&f=ifr&linkID=0dc57b53bcc8f7ab67a385d51155e57a&t=techtinkering-21&tracking_id=techtinkering-21" width="300" height="250" scrolling="no" border="0" marginwidth="0" style="border:none;" frameborder="0" sandbox="allow-scripts allow-same-origin allow-popups allow-top-navigation-by-user-activation"><' + '/iframe><' + '/div>';
    } else {
      console.log("Google Ads - non-uk user");
      (adsbygoogle = window.adsbygoogle || []).push({
           google_ad_client: "ca-pub-1613732348909658",
           enable_page_level_ads: true
      });
    }
  </script>

</head>
  <body>
    <nav>
  <div class="container">
    <div class="navbar-header">
      <a href="/">TechTinkering</a><br />
      =============
    </div>

    <div class="contact">
      <ul>
        <li>
          <a href="https://twitter.com/TechTinkering" title="@TechTinkering on Twitter">Twitter</a>
        </li>
        <li>
          <a href="https://youtube.com/techtinkering" title="TechTinkering's YouTube Channel">YouTube</a>
        </li>
        <li>
          <a href="https://feeds.feedburner.com/TechTinkering" title="Subscribe to our RSS Feed">RSS</a>
        </li>
        <li>
          <a href="mailto:techtinkering@vlifesystems.com" title="Email us, we'd love to hear from you">Email</a>
        </li>
        <li>
          <a href="/useful-links/" title="Useful vintage computer links">Useful Links</a>
        </li>
      </ul>
    </div>
  </div>
</nav>
    <div id="content" class="container">
      <div class="margin-buffer">
    <article itemscope itemtype="http://schema.org/BlogPosting">
    <meta itemprop="image"
         content="https://techtinkering.com/img/social_images/6502_pic_make_data_table_assembly.png" />
      <header>
        <a href="/articles/position-independent-code-6502-on-the-commodore-vic-20/" title="Position Independent Code (6502) on the Commodore VIC-20">
          <h1 itemprop="headline name">Position Independent Code (6502) on the Commodore VIC-20</h1>
        </a>
        <div>
            <time itemprop="datePublished"
                  datetime="2020-02-04">
               4 February 2020
            </time>
          <span itemscope itemprop="publisher"
                itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="TechTinkering" />
            <meta itemprop="url" content="https://techtinkering.com" />
          </span>
          <span itemscope itemprop="author" itemtype="http://schema.org/Person">
            <a rel="author" itemprop="url" href="https://lawrencewoodman.github.io">
              <span itemprop="name">Lawrence Woodman</span>
            </a>
          </span>

          <ul class="tags">
              <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
              <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
              <li>#<a href="/articles/tag/programming/">Programming</a></li>
              <li>#<a href="/articles/tag/retro/">Retro</a></li>
              <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
          </ul>
        </div>
      </header>

      <script>
        if (isUserFromUK()) {
          document.write(amznBanner);
        }
      </script>

        <div itemprop="articleBody">
        <p>If we are writing 6502 machine code and want to to create a routine or program that can be placed in any location then we have to create <em>Position Independent Code (PIC)</em> or make the code relocatable.  Here I'm going to show how to make our code  <em>Position Independent</em>.  There are three full examples near the end of the article which show how to put this altogether.</p>
<h2>Branches Instead of Jumps</h2>
<p>One of the first things we can do is use branches instead of <code>JMP</code> to an absolute address where possible.  This is because branches jump to a relative address that will still be the same if the code moves.  A branch allows a relative jump to an address -127/+128 bytes from the current address.</p>
<p>To do something similar to a <code>BRA</code> (BRanch Always) we just need to force the condition before using one of the Branch instructions.  An easy one to use is <code>BVC</code> (Branch on oVerflow Clear) as the <em>oVerflow</em> flag is only altered by the <code>ADC</code>, <code>BIT</code>, <code>CLV</code> and <code>SBC</code> instructions which makes it easy to keep track of.</p>
<p>The following absolute jump:</p>
<pre><code class="language-asm6502">            jmp label          ; 3 bytes, 3 cycles
            ...
            ...
label       nop
</code></pre>
<p>can easily be turned into a relative jump:</p>
<pre><code class="language-asm6502">            clv                ; 1 byte,  2 cycles
            bvc label          ; 2 bytes, 3-4 cycles (depending on page cross)
            ...
            ...
label       nop
</code></pre>
<p>Both jumps take 3 bytes of code, but we can see that the relative jump takes 2-3 more cycles to complete and therefore this is something to keep an eye on.  If you are sure that the <em>oVerflow</em> flag is clear then you can omit the <code>CLV</code> and actually save 1 byte and only take 0-1 more cycles to complete.</p>
<h2>Indirect Jumps for Long Jumps</h2>
<p>If the location we want to jump to is going to be further than -127/+128 bytes away then we can put the location we want to jump to in fixed memory address and then jump to that location indirectly.  We may want to do this using a data table as described further down the article.</p>
<p>To compare, here is an absolute <code>JMP</code></p>
<pre><code class="language-asm6502">            jmp labelA                ; 3 bytes, 3 cycles
</code></pre>
<p>Here is an indirect <code>JMP</code> using a data table with ILABELA as an index.  We can see that there is a 2 cycle overhead per <code>JMP</code>.</p>
<pre><code class="language-asm6502">            jmp (DATA_TABLE+ILABELA)  ; 3 bytes, 5 cycles
</code></pre>
<h2>A Data Table to Access Memory Indirectly</h2>
<p>To access memory locations that would move with the code we can create a data table in a static location that contains pointers to each location in the code.  This would be accessed via an index using indirect addressing.</p>
<p>Here is a '<em>Hello, World!</em>' routine that uses a static location for <code>helloMsg</code> which we will convert in the second piece of code to become <em>Position Independent</em> by using a data table.</p>
<pre><code class="language-asm6502">CCHROUT    = $FFD2             ; Output character to current output device

helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0

            ; Non position independent
SayHello    .(
            ; Output message
            ldy #$00
loop        lda helloMsg, y               ; 3 bytes, 4-5 cycles (depending on page cross)
            beq finished
            jsr CCHROUT                   ; Output char to screen
            iny
            bne loop
finished    rts
.)
</code></pre>
<br />
<p>The following <em>Hello World</em> routine adapts the one above and makes it <em>Position Independent</em> by looking up the address of <code>helloMsg</code> in <code>DATA_TABLE</code> using <code>IHELLOMSG</code> as an index and storing it in <code>TMP_DPTR</code>.  <code>TMP_DPTR</code> is then accessed using indirect addressing by <code>LDA</code>.  <code>DATA_TABLE</code> is located in the cassette buffer at <code>$0334</code>.</p>
<pre><code class="language-asm6502">CHR_RTN    = $0D               ; Return character
CCHROUT    = $FFD2             ; Output character to current output device
TMP_DPTR   = $FB               ; Temporary data pointer
DATA_TABLE = $0334             ; The location of the data table
IHELLOMSG  = 0                 ; Index to 'HELLO, WORLD!' message

helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0

            ; Position Independent
SayHello    .(
            ; Point TMP_DPTR to helloMsg
            lda DATA_TABLE+IHELLOMSG      ; 3 bytes, 4 cycles
            sta TMP_DPTR                  ; 2 bytes, 3 cycles
            lda DATA_TABLE+IHELLOMSG+1    ; 3 bytes, 4 cycles
            sta TMP_DPTR+1                ; 2 bytes, 3 cycles

            ; Output message
            ldy #$00
loop        lda (TMP_DPTR), y             ; 2 bytes, 5-6 cycles (depending on page cross)
            beq finished
            jsr CCHROUT                   ; Output char to screen
            iny
            bne loop
finished    rts
.)
</code></pre>
<p>If we compare the two routines we can see that there is an 8 byte overhead for the <em>PIC</em> using a data table and a 15 cycle overhead.  This is in addition to the overhead of creating the data table in the first place.</p>
<h2>A Jump Table for Subroutine Calls</h2>
<p>The <code>JSR</code> (Jump to Subroutine) instruction can only jump to absolute addresses.  One easy way to overcome this is to use a jump table.  This will contain a series of jumps to the correct location for each subroutine.</p>
<p>The jump table would contain code such as the following:</p>
<pre><code class="language-asm6502">CPRINTSCORE   jmp  $1420
CPRINTLIVES   jmp  $1430
CSHIPLEFT     jmp  $1440
CSHIPRIGHT    jmp  $1460
</code></pre>
<p>Then all the <em>PIC</em> would do is <code>JSR</code> to one of the locations in the jump table which would then jump to the location of the subroutine.  E.g. if a game contained <em>PIC</em> that wanted to move the ship left it would run the following:</p>
<pre><code class="language-asm6502">              jsr CSHIPLEFT
</code></pre>
<p>The jump table would have to be placed in a static location unless self-modifying code is used.  One possible location for the jump table could be at <em>$02A1-02FF</em> which is reserved for program indirects.  This would be enough room for a jump table containing 31 jumps.</p>
<p>The extra <code>JMP</code> instruction adds a 3 cycle overhead to every <code>JSR</code> instruction. This is in addition to the overhead of creating the jump table in the first place.</p>
<h2>Getting the Program Counter</h2>
<p>There are few situations where we would need to get the Program Counter because we could just get the address of the start of the code from the loader.  However, in case a situation arises or just for curiosity we can get the address of the <em>Program Counter</em> with the code that follows.  This code should be copied to a static address, such as the cassette buffer, and <code>JSR</code> should call it to put the address of the calling <code>JSR</code> in <code>PC</code>.</p>
<pre><code class="language-asm6502">PC        = $09                ; Location to store PC in

            ; Put address of calling JSR into PC
GetPC       .(
            pla
            sta PC             ; Store the 16-bit program counter at PC
            pla
            sta PC+1
            pha                ; Restore the return address to the stack
            lda PC
            pha
            bne decL1          ; Decrement PC by 2 to point to calling instruction
            dec PC+1
decL1       dec PC
            bne decL2
            dec PC+1
decL2       dec PC
            rts
.)
</code></pre>
<p>This works because <code>JSR</code> puts the PC+2 onto the stack and <code>RTS</code> takes two bytes from the stack, increments them and jumps to this address.</p>
<h2>Calculating Absolute Addresses</h2>
<p>To access data and run subroutines we need to calculate absolute addresses for them.  This can be done by using offsets from a certain point in the code and adding them to that point once its absolute addresses has been determined.  The absolute address of our reference point could be supplied by the machine code loader or sought using the <code>GetPC</code> routine above.</p>
<p>The following code shows how the absolute address used in a data table could be calculated to refer to a region of memory containing a <em>Hello, World</em> message.</p>
<pre><code class="language-asm6502">CHR_RTN    = $0D               ; Return character

PC         = $09               ; Location to store PC in
DATA_TABLE = $0334             ; The location of the data table
IHELLOMSG  = 0                 ; Index to 'HELLO, WORLD!' message

            * = $1001

start       jsr GetPC          ; Put absolute address of start in PC

            ; BRanch Always
            clv
            bvc makeDTable

helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0

            ; Make data table
makeDTable  clc
            lda PC
            adc #&lt;(helloMsg-start)      ; LSB of offset from start
            sta DATA_TABLE+IHELLOMSG
            lda PC+1
            adc #&gt;(helloMsg-start)      ; MSB of offset from start
            sta DATA_TABLE+IHELLOMSG+1
</code></pre>
<h2>Self-Modifying Code</h2>
<p>We can avoid the use of jump tables and data tables by using self-modifying code.  This can create quicker, smaller and more readable code, but it isn't possible to do this if the code is located in ROM.</p>
<p>To create self-modifying code we can create a table which contains address offsets to change.  The address offsets will be offset from a location in the code and at run-time the values at these addresses will be changed to absolute addresses.</p>
<pre><code class="language-asm6502">TXTTAB     = $2B               ; Pointer to start of tokenized Basic
SMADDR     = $09               ; Address to modify
PSMTABLE   = $FB               ; Pointer to self-modification table
CHR_RTN    = $0D               ; Return character


            ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
            ; Code has been removed here to create a
            ; Basic stub with first byte of stub
            ; labeled 'start'.  Where the stub is
            ; loaded can be found by looking at
            ; TXTTAB.
            ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

            ;=========================================
            ; Start of machine language
            ;=========================================
mLang
            * = mLang-start

            ; BRanch Always
            clv
            bvc setupSM

            ;-----------------------------------------
            ; Message strings
            ;-----------------------------------------
helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0
byeMsg     .asc &quot;GOODBYE, WORLD!&quot; : .byt CHR_RTN : .byt 0

            ;=========================================
            ; Self-modification
            ;=========================================

            ;-----------------------------------------
            ; Self-modification table
            ; offsetAddr
            ;-----------------------------------------
smTable     .word main+1       ; Address of SayHello routine
            .word main+4       ; Address of SayGoodbye routine
            .word SayHello+3   ; Entry within SayHello
                               ; routine pointing to helloMsg
            .word SayGoodbye+3 ; Entry within SayGoodbye
                               ; routine pointing to byeMsg
            .word 0            ; End of table

            ;-----------------------------------------
            ; Self-modify code to point to correct
            ; locations
            ;-----------------------------------------

setupSM     .(
            ; Create pointer to smTable
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;smTable
            sta PSMTABLE
            lda TXTTAB+1
            adc #&gt;smTable
            sta PSMTABLE+1

            ; Point offsets in smTable to absolute addresses
            ldy #00
            lda (PSMTABLE), y
loop       ; Calculate address to change
            clc
            adc TXTTAB
            sta SMADDR
            iny
            lda TXTTAB+1
            adc (PSMTABLE), y
            iny
            sta SMADDR+1
            ; Move value at address
            tya
            tax
            ldy #00
            clc
            lda TXTTAB
            adc (SMADDR), y
            sta (SMADDR), y
            iny
            lda TXTTAB+1
            adc (SMADDR), y
            sta (SMADDR), y
            txa
            tay
            lda (PSMTABLE), y
            bne loop           ; If not end of table
.)

            ;=========================================
            ; MAIN program
            ;=========================================
main        jsr SayHello
            jsr SayGoodbye
            rts
</code></pre>
<h2>Video Demonstrating Position Independent Code</h2>
<p>You can see <em>Position Independent Code</em> explained and run in the following video:</p>
<div class="youtube-wrapper">
<iframe width="560" height="315" src="https://www.youtube.com/embed/qil0QJO_5xo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2>Full Examples</h2>
<p>The examples have been written for the <a href="https://www.floodgap.com/retrotech/xa/">XA</a> assembler and are hosted on GitHub: <a href="https://github.com/lawrencewoodman/position_independent_code_vic20">position_independent_code_vic20</a>.</p>
<h3>Position Independent Code Without Self-Modification</h3>
<p>The code below demonstrates creating a jump and data table to point to the subroutines and their associated message data.  The code contains a <a href="/articles/adding-basic-stubs-to-assembly-language-on-the-commodore-vic-20/" title="Adding Basic Stubs to Assembly Language on the Commodore VIC-20">Basic stub</a> to make the code easier to load and test.  It relies on location <em>$2B/$2C</em> (<code>TXTAB</code>) pointing to the start of tokenized Basic so that it can use this as a reference point to calculate the absolute addresses in the rest of the code.  The start of tokenized Basic will change depending on the memory configuration of the Vic, but the machine language code will work regardless because it is <em>Position Independent</em>.</p>
<pre><code class="language-asm6502">; Basic Stub
OPEN_PR    = $28               ; ( character
CLOSE_PR   = $29               ; ) character
PLUS       = $AA               ; + character
TIMES      = $AC               ; * character
TOK_PEEK   = $C2               ; PEEK token
TOK_SYS    = $9E               ; SYS token

CHR_RTN    = $0D               ; Return character
OP_JMPA    = $4C               ; JMP absolute opcode
TXTTAB     = $2B               ; Pointer to start of tokenized Basic
CCHROUT    = $FFD2             ; Output character to current output device

TMP_DPTR   = $FB               ; Temporary data pointer
JMP_TABLE  = $02A1             ; The location of the jump table
DATA_TABLE = $0334             ; The location of the data table
IHELLOMSG  = 0                 ; Index to 'HELLO, WORLD!' message
IBYEMSG    = IHELLOMSG+2       ; Index to 'GOODBYE, WORLD!' message
CSAYHELLO  = JMP_TABLE         ; Vector to SayHello
CSAYBYE    = JMP_TABLE+3       ; Vector to SayGoodbye


            .byt $01, $80      ; Load Address.  Using character ROM because
                               ; correct RAM location memory configuration
                               ; dependent


            ;=========================================
            ;  Basic Stub
            ;=========================================

            ; 2020 SYS PEEK(43)+PEEK(44)*256+27
            * = $1001
start       .word basicEnd     ; Next Line link, here end of Basic program
            .word 2020         ; The line number for the SYS statement
            .byt  TOK_SYS      ; SYS token
            .asc  &quot; &quot;
            .byt  TOK_PEEK     ; PEEK token
            .byt  OPEN_PR      ; (
            .asc  &quot;43&quot;         ; 43
            .byt  CLOSE_PR     ; )
            .byt  PLUS         ; +
            .byt  TOK_PEEK     ; PEEK token
            .byt  OPEN_PR      ; (
            .asc  &quot;44&quot;         ; 44
            .byt  CLOSE_PR     ; )
            .byt  TIMES        ; *
            .asc  &quot;256&quot;        ; 256
            .byt  PLUS         ; +
            .asc  &quot;27&quot;         ; 27 (The size of the stub)
            .byt  0            ; End of Basic line
basicEnd    .word 0            ; End of Basic program


            ;=========================================
            ; Start of machine language
            ;=========================================

            ; BRanch Always
            clv
            bvc makeJTable

            ;-----------------------------------------
            ; Message strings
            ;-----------------------------------------
helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0
byeMsg     .asc &quot;GOODBYE, WORLD!&quot; : .byt CHR_RTN : .byt 0


            ;=========================================
            ; Create jump and data tables
            ;=========================================

            ;-----------------------------------------
            ; Create jump table
            ;-----------------------------------------

            ; Store JMP absolute opcodes
makeJTable  lda #OP_JMPA       ; JMP absolute opcode
            sta CSAYHELLO
            sta CSAYBYE

            ; Jump table address for SayHello
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;(SayHello-start)
            sta CSAYHELLO+1
            lda TXTTAB+1
            adc #&gt;(SayHello-start)
            sta CSAYHELLO+2

            ; Jump table address for SayGoodbye
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;(SayGoodbye-start)
            sta CSAYBYE+1
            lda TXTTAB+1
            adc #&gt;(SayGoodbye-start)
            sta CSAYBYE+2

            ;-----------------------------------------
            ; Create data table
            ;-----------------------------------------

            ; Point entry at index IHELLOMSG to helloMsg
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;(helloMsg-start)
            sta DATA_TABLE+IHELLOMSG
            lda TXTTAB+1
            adc #&gt;(helloMsg-start)
            sta DATA_TABLE+IHELLOMSG+1

            ; Point entry at index IBYEMSG to byeMsg
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;(byeMsg-start)
            sta DATA_TABLE+IBYEMSG
            lda TXTTAB+1
            adc #&gt;(byeMsg-start)
            sta DATA_TABLE+IBYEMSG+1


            ;=========================================
            ; MAIN program
            ;=========================================
            jsr CSAYHELLO
            jsr CSAYBYE
            rts


            ;=========================================
            ; Subroutines
            ;=========================================

            ;-----------------------------------------
            ; SayHello
            ; Displays 'HELLO, WORLD!' message
            ;-----------------------------------------
SayHello    .(
            ; Point TMP_DPTR to helloMsg
            lda DATA_TABLE+IHELLOMSG
            sta TMP_DPTR
            lda DATA_TABLE+IHELLOMSG+1
            sta TMP_DPTR+1

            ; Output message
            ldy #$00
loop        lda (TMP_DPTR), y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)

            ;-----------------------------------------
            ; SayGoodbye
            ; Displays 'GOODBYE, WORLD!' message
            ;-----------------------------------------
SayGoodbye  .(
            ; Point TMP_DPTR to byeMsg
            lda DATA_TABLE+IBYEMSG
            sta TMP_DPTR
            lda DATA_TABLE+IBYEMSG+1
            sta TMP_DPTR+1

            ; Output message
            ldy #$00
loop        lda (TMP_DPTR), y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)
</code></pre>
<h3>Position Independent Code Using Self-Modification</h3>
<p>This example also uses a <a href="/articles/adding-basic-stubs-to-assembly-language-on-the-commodore-vic-20/" title="Adding Basic Stubs to Assembly Language on the Commodore VIC-20">Basic stub</a> and the <code>TXTTAB</code> location mentioned in the previous example.  We can see that the code below is shorter, easier to read and would run faster once the self-modification had been completed.  However, self modifying code can't be placed in ROM.</p>
<pre><code class="language-asm6502">; Basic Stub
OPEN_PR    = $28               ; ( character
CLOSE_PR   = $29               ; ) character
PLUS       = $AA               ; + character
TIMES      = $AC               ; * character
TOK_PEEK   = $C2               ; PEEK token
TOK_SYS    = $9E               ; SYS token

; Self Modification
TXTTAB     = $2B               ; Pointer to start of tokenized Basic
SMADDR     = $09               ; Address to modify
PSMTABLE   = $FB               ; Pointer to self-modification table

; Character output
CHR_RTN    = $0D               ; Return character
CCHROUT    = $FFD2             ; Output character to current output device


            .byt $01, $80      ; Load Address.  Using character ROM because
                               ; correct RAM location memory configuration
                               ; dependent


            ;=========================================
            ;  Basic Stub
            ;=========================================
            * = $1001

            ; 2020 SYS PEEK(43)+PEEK(44)*256+27
start       .word basicEnd     ; Next Line link, here end of Basic program
            .word 2020         ; The line number for the SYS statement
            .byt  TOK_SYS      ; SYS token
            .asc  &quot; &quot;
            .byt  TOK_PEEK     ; PEEK token
            .byt  OPEN_PR      ; (
            .asc  &quot;43&quot;         ; 43
            .byt  CLOSE_PR     ; )
            .byt  PLUS         ; +
            .byt  TOK_PEEK     ; PEEK token
            .byt  OPEN_PR      ; (
            .asc  &quot;44&quot;         ; 44
            .byt  CLOSE_PR     ; )
            .byt  TIMES        ; *
            .asc  &quot;256&quot;        ; 256
            .byt  PLUS         ; +
            .asc  &quot;27&quot;         ; 27 (The size of the stub)
            .byt  0            ; End of Basic line
basicEnd    .word 0            ; End of Basic program


            ;=========================================
            ; Start of machine language
            ;=========================================
mLang
            * = mLang-start

            ; BRanch Always
            clv
            bvc setupSM

            ;-----------------------------------------
            ; Message strings
            ;-----------------------------------------
helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0
byeMsg     .asc &quot;GOODBYE, WORLD!&quot; : .byt CHR_RTN : .byt 0


            ;=========================================
            ; Self-modification
            ;=========================================

            ;-----------------------------------------
            ; Self-modification table
            ; offsetAddr
            ;-----------------------------------------
smTable     .word main+1
            .word main+4
            .word SayHello+3
            .word SayGoodbye+3
            .word 0            ; End of table

            ;-----------------------------------------
            ; Self-modify code to point to correct
            ; locations
            ;-----------------------------------------

setupSM     .(
            ; Create pointer to smTable
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;smTable
            sta PSMTABLE
            lda TXTTAB+1
            adc #&gt;smTable
            sta PSMTABLE+1

            ; Skip self-modication if has already been run
            ; This isn't needed if sure code will only be run once
            ldy #01
            lda (PSMTABLE), y
            cmp #$FF           ; Page $FF indicates SM already run
            beq main

            ; Point offsets in smTable to absolute addresses
            ldy #00
            lda (PSMTABLE), y
loop       ; Calculate address to change
            clc
            adc TXTTAB
            sta SMADDR
            iny
            lda TXTTAB+1
            adc (PSMTABLE), y
            iny
            sta SMADDR+1
            ; Move value at address
            tya
            tax
            ldy #00
            clc
            lda TXTTAB
            adc (SMADDR), y
            sta (SMADDR), y
            iny
            lda TXTTAB+1
            adc (SMADDR), y
            sta (SMADDR), y
            txa
            tay
            lda (PSMTABLE), y
            bne loop           ; If not end of table

            ; Record that self-modification has been run
            ; by setting page of first address to $FF
            ldy #01
            lda #$FF
            sta (PSMTABLE), y
.)

            ;=========================================
            ; MAIN program
            ;=========================================
main        jsr SayHello
            jsr SayGoodbye
            rts


            ;=========================================
            ; Subroutines
            ;=========================================

            ;-----------------------------------------
            ; SayHello
            ; Displays 'HELLO, WORLD!' message
            ;-----------------------------------------
SayHello    .(
            ; Output message
            ldy #$00
loop        lda helloMsg, y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)

            ;-----------------------------------------
            ; SayGoodbye
            ; Displays 'GOODBYE, WORLD!' message
            ;-----------------------------------------
SayGoodbye  .(
            ; Output message
            ldy #$00
loop        lda byeMsg, y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)
</code></pre>
<h3>Position Independent Code Getting Absolute Address of Point in Code</h3>
<p>The last example shows how we can determine the absolute address of a point in the code from which we can calculate offsets.  The code works by creating a routine at <em>$02A1</em> to get the Program Counter (<code>GetPC</code>).  Once an absolute address has been determined all the other addresses can be calculated in relation to that address.</p>
<p>This example doesn't use a Basic stub, but does specify address <em>$1203</em> as its load address.  This address should work for all memory configurations.  To load and run it we could use:</p>
<pre><code class="language-basic">LOAD &quot;*&quot;,8,1
SYS 4611
</code></pre>
<p>We can change the load address and as long as it's a valid area for our Vic and we <code>SYS</code> to the correct address, the code will work fine.</p>
<pre><code class="language-asm6502">; Opcodes
OP_BNE     = $D0               ; BNE
OP_DECA    = $CE               ; DEC absolute
OP_JMPA    = $4C               ; JMP absolute
OP_PHA     = $48               ; PHA
OP_PLA     = $68               ; PLA
OP_RTS     = $60               ; RTS
OP_LDAA    = $AD               ; LDA absolute
OP_STAA    = $8D               ; STA absolute

CHR_RTN    = $0D               ; Return character
CCHROUT    = $FFD2             ; Output character to current output device

PC         = $09               ; Location to store PC in
TMP_DPTR   = $FB               ; Temporary data pointer
JMP_TABLE  = $02A1             ; The location of the jump table
DATA_TABLE = $0334             ; The location of the data table
IHELLOMSG  = 0                 ; Index to 'HELLO, WORLD!' message
IBYEMSG    = IHELLOMSG+2       ; Index to 'GOODBYE, WORLD!' message
CSAYHELLO  = JMP_TABLE         ; Vector to SayHello
CSAYBYE    = JMP_TABLE+3       ; Vector to SayGoodbye

GetPC      = $02A1             ; Location of GetPC routine

            .byt $03, $12      ; Load Address.
                               ; $1203 should work for any memory configuration


            ;=========================================
            ; Static data
            ;=========================================
            * = $1203

            ; BRanch Always
            clv
            bvc start

            ;-----------------------------------------
            ; Message strings
            ;-----------------------------------------
helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0
byeMsg     .asc &quot;GOODBYE, WORLD!&quot; : .byt CHR_RTN : .byt 0


            ;=========================================
            ; Determine Absolute address for start of
            ; code
            ;=========================================

            ;-----------------------------------------
            ;  Create GetPC at $02A1
            ;-----------------------------------------
start       lda #OP_PLA        ; PLA
            sta GetPC
            lda #OP_STAA       ; STA PC
            sta GetPC+1        ; - Store the 16-bit program counter at PC
            lda #&lt;PC           ;
            sta GetPC+2
            lda #&gt;PC
            sta GetPC+3
            lda #OP_PLA        ; PLA
            sta GetPC+4
            lda #OP_STAA       ; STA PC+1
            sta GetPC+5
            lda #&lt;PC+1
            sta GetPC+6
            lda #&gt;PC+1         ; Using MSB of PC in case moved out of zero page
            sta GetPC+7
            lda #OP_PHA        ; PHA
            sta GetPC+8        ; - Restore the return address to the stack
            lda #OP_LDAA       ; LDA PC
            sta GetPC+9
            lda #&lt;PC
            sta GetPC+10
            lda #&gt;PC
            sta GetPC+11
            lda #OP_PHA        ; PHA
            sta GetPC+12
            lda #OP_BNE        ; BNE decL1
            sta GetPC+13       ; - PC=PC-2 to point to calling instruction
            lda #$03
            sta GetPC+14
            lda #OP_DECA      ; DEC PC+1
            sta GetPC+15       ; - MSB
            lda #&lt;PC+1
            sta GetPC+16
            lda #&gt;PC+1
            sta GetPC+17
            lda #OP_DECA      ; decL1:  DEC PC
            sta GetPC+18       ; - LSB
            lda #&lt;PC
            sta GetPC+19
            lda #&gt;PC
            sta GetPC+20
            lda #OP_BNE        ; BNE decL2
            sta GetPC+21
            lda #$03
            sta GetPC+22
            lda #OP_DECA      ; DEC PC+1
            sta GetPC+23
            lda #&lt;PC+1
            sta GetPC+24
            lda #&gt;PC+1
            sta GetPC+25
            lda #OP_DECA      ; decL2:  DEC PC
            sta GetPC+26
            lda #&lt;PC
            sta GetPC+27
            lda #&gt;PC
            sta GetPC+28
            lda #OP_RTS        ; RTS
            sta GetPC+29

callGetPC   jsr GetPC          ; Get absolute address of callGetPC


            ;=========================================
            ; Create jump and data tables
            ;=========================================

            ;-----------------------------------------
            ; Create jump table
            ;-----------------------------------------

            ; Store JMP absolute opcodes
            lda #OP_JMPA       ; JMP absolute opcode
            sta CSAYHELLO
            sta CSAYBYE

            ; Jump table address for SayHello
            clc
            lda PC
            adc #&lt;(SayHello-callGetPC)
            sta CSAYHELLO+1
            lda PC+1
            adc #&gt;(SayHello-callGetPC)
            sta CSAYHELLO+2

            ; Jump table address for SayGoodbye
            clc
            lda PC
            adc #&lt;(SayGoodbye-callGetPC)
            sta CSAYBYE+1
            lda PC+1
            adc #&gt;(SayGoodbye-callGetPC)
            sta CSAYBYE+2

            ;-----------------------------------------
            ; Create data table
            ;-----------------------------------------

            ; Point entry at index IHELLOMSG to helloMsg
            clc
            lda PC
            adc #&lt;(helloMsg-callGetPC)
            sta DATA_TABLE+IHELLOMSG
            lda PC+1
            adc #&gt;(helloMsg-callGetPC)
            sta DATA_TABLE+IHELLOMSG+1

            ; Point entry at index IBYEMSG to byeMsg
            clc
            lda PC
            adc #&lt;(byeMsg-callGetPC)
            sta DATA_TABLE+IBYEMSG
            lda PC+1
            adc #&gt;(byeMsg-callGetPC)
            sta DATA_TABLE+IBYEMSG+1


            ;=========================================
            ; MAIN program
            ;=========================================
            jsr CSAYHELLO
            jsr CSAYBYE
            rts


            ;=========================================
            ; Subroutines
            ;=========================================

            ;-----------------------------------------
            ; SayHello
            ; Displays 'HELLO, WORLD!' message
            ;-----------------------------------------
SayHello    .(
            ; Point TMP_DPTR to helloMsg
            lda DATA_TABLE+IHELLOMSG
            sta TMP_DPTR
            lda DATA_TABLE+IHELLOMSG+1
            sta TMP_DPTR+1

            ; Output message
            ldy #$00
loop        lda (TMP_DPTR), y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)

            ;-----------------------------------------
            ; SayGoodbye
            ; Displays 'GOODBYE, WORLD!' message
            ;-----------------------------------------
SayGoodbye  .(
            ; Point TMP_DPTR to byeMsg
            lda DATA_TABLE+IBYEMSG
            sta TMP_DPTR
            lda DATA_TABLE+IBYEMSG+1
            sta TMP_DPTR+1

            ; Output message
            ldy #$00
loop        lda (TMP_DPTR), y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)
</code></pre>
      </div>
    </article>
</div>

<script>
  if (isUserFromUK()) {
    document.write(amznBanner);
  }
</script>

  <div id="cclicence">
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
      <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
    </a>
    <br />
    <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Position Independent Code (6502) on the Commodore VIC-20</span>
    by <a xmlns:cc="http://creativecommons.org/ns#" href="https://techtinkering.com/articles/position-independent-code-6502-on-the-commodore-vic-20/" property="cc:attributionName" rel="cc:attributionURL">Lawrence Woodman</a>
   is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
   
  </div>


  <div class="discuss">
    <h2 style="margin-top:0;">Share This Post</h2>
    <div class="contact">
  <ul>
    <li><a href="http://www.reddit.com/submit?url=https%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F&title=Position%20Independent%20Code%20%286502%29%20on%20the%20Commodore%20VIC-20" target="_blank" title="Submit to Reddit">Reddit</a></li>
    <li><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F&quote=Position%20Independent%20Code%20%286502%29%20on%20the%20Commodore%20VIC-20" target="_blank" title="Share on Facebook">Facebook</a></li>
    <li><a href="https://twitter.com/intent/tweet?source=https%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F&text=Position%20Independent%20Code%20%286502%29%20on%20the%20Commodore%20VIC-20:%0Ahttps%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F&via=TechTinkering" target="_blank" title="Tweet">Twitter</a></li>
    <li><a href="mailto:?subject=Position%20Independent%20Code%20%286502%29%20on%20the%20Commodore%20VIC-20&body=If%20we%20are%20writing%206502%20machine%20code%20and%20want%20to%20to%20create%20a%20routine%20or%20program%20that%20can%20be%20placed%20in%20any%20location%20then%20we%20have%20to%20create%20Position%20Independent%20Code%20%28PIC%29%20or%20make%20the%20code%20relocatable.%20%20H...:%0A%0Ahttps%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F" target="_blank" title="Send email">Email</a></li>
  </ul>
</div>

    <h2>Feedback/Discuss</h2>
    <div class="contact">
  <ul>
      <li><a href="https://twitter.com/TechTinkering/status/1224674967348031488" target="_blank" title="Discuss on Twitter">Twitter</a></li>


    <li><a href="mailto:techtinkering@vlifesystems.com?subject=Comment:%20Position%20Independent%20Code%20%286502%29%20on%20the%20Commodore%20VIC-20&body=Article%20URL:%20https%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F%0A" title="Send us an email">Email</a></li>
  </ul>
</div>
  </div>


    <div>
    <h2>Related Articles</h2>
    <div class="margin-buffer">
      <header>
  <h2><a href="/articles/getting-the-address-of-basic-variables-on-the-vic-20/">Getting the Address of BASIC Variables on the VIC-20</a></h2>
  <span class="post-meta">
      <ul class="tags">
          <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
          <li>#<a href="/articles/tag/basic/">BASIC</a></li>
          <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
          <li>#<a href="/articles/tag/programming/">Programming</a></li>
          <li>#<a href="/articles/tag/retro/">Retro</a></li>
          <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
      </ul>
  </span>
</header>
<div>
  Getting the address of a BASIC variable can be useful if you want to pass data to a machine code routine or want to access the bytes of a variable directly to improve speed and reduce garbage collectio...
  &nbsp;
  <a class="readMore" href="/articles/getting-the-address-of-basic-variables-on-the-vic-20/">Read More</a>
</div>
<br />
      <header>
  <h2><a href="/articles/saving-and-loading-memory-on-the-vic-20/">Saving and Loading Memory on the VIC-20</a></h2>
  <span class="post-meta">
      <ul class="tags">
          <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
          <li>#<a href="/articles/tag/basic/">BASIC</a></li>
          <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
          <li>#<a href="/articles/tag/programming/">Programming</a></li>
          <li>#<a href="/articles/tag/retro/">Retro</a></li>
          <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
      </ul>
  </span>
</header>
<div>
  Saving and loading memory is quite easy on the VIC-20 once you know how.  However, it isn't obvious how to do this and therefore this article will present a few simple ways of doing it from BASIC and A...
  &nbsp;
  <a class="readMore" href="/articles/saving-and-loading-memory-on-the-vic-20/">Read More</a>
</div>
<br />
      <header>
  <h2><a href="/articles/programming-in-assembly-with-vicmon-on-the-vic-20/">Programming in Assembly with VICMON on the VIC-20</a></h2>
  <span class="post-meta">
      <ul class="tags">
          <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
          <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
          <li>#<a href="/articles/tag/programming/">Programming</a></li>
          <li>#<a href="/articles/tag/retro/">Retro</a></li>
          <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
      </ul>
  </span>
</header>
<div>
  VICMON is a machine language monitor released by Commodore in 1982 and is great for programming the VIC-20.  Its interactive nature means that it can often be quicker to develop via this rather than us...
  &nbsp;
  <a class="readMore" href="/articles/programming-in-assembly-with-vicmon-on-the-vic-20/">Read More</a>
</div>
<br />
      <header>
  <h2><a href="/articles/storing-machine-code-in-rem-statements-on-the-vic-20/">Storing Machine Code in REM Statements on the VIC-20</a></h2>
  <span class="post-meta">
      <ul class="tags">
          <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
          <li>#<a href="/articles/tag/basic/">BASIC</a></li>
          <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
          <li>#<a href="/articles/tag/programming/">Programming</a></li>
          <li>#<a href="/articles/tag/retro/">Retro</a></li>
          <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
      </ul>
  </span>
</header>
<div>
  BASIC programs often contain machine code routines but they take up quite a lot of space in BASIC.  An interesting way to reduce the amount of space that they take is to store the machine code in REM s...
  &nbsp;
  <a class="readMore" href="/articles/storing-machine-code-in-rem-statements-on-the-vic-20/">Read More</a>
</div>
<br />
      <header>
  <h2><a href="/articles/code-and-data-in-display-memory-on-the-vic-20/">Code and Data in Display Memory on the VIC-20</a></h2>
  <span class="post-meta">
      <ul class="tags">
          <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
          <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
          <li>#<a href="/articles/tag/programming/">Programming</a></li>
          <li>#<a href="/articles/tag/retro/">Retro</a></li>
          <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
      </ul>
  </span>
</header>
<div>
  The unexpanded Commodore VIC-20 only had 5K of RAM and therefore creative ways had to be found to maximize the available RAM.  The display memory would use some of this memory and therefore one option ...
  &nbsp;
  <a class="readMore" href="/articles/code-and-data-in-display-memory-on-the-vic-20/">Read More</a>
</div>
<br />
</div>
    </div>

<script>
  if (isUserFromUK()) {
    document.write(amznBanner);
  }
</script>
    </div>

    <footer>
  <nav>
    <div class="container">
      <div>
        <strong>Legal:</strong>
        <a href="/terms/">T & C</a>, <a href="/privacy/">Privacy Policy</a>
        &nbsp;
        <strong>Misc:</strong>
        <a href="https://github.com/lawrencewoodman/techtinkering.com" title="Fork TechTinkering On GitHub ">GitHub</a>
        <script>
          if (isUserFromUK()) {
            document.write('<br /><strong>Disclosure:<' +'/strong> As an Amazon Associate TechTinkering earns from qualifying purchases.');
          }
        </script>
      </div>
    </div>
  </nav>
</footer>
  </body>
</html>