<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
  <title>Position Independent Code (6502) on the Commodore VIC-20</title>
  <meta name="description" content="If we are writing 6502 machine code and want to to create a routine or program that can be placed in any location then we have to create Position Independent Cod">
  <meta name="keywords" content="Retro Vintage Programming Tinkering"/>

  <!-- *** Twitter Card *** -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@techtinkering">
  <meta name="twitter:title" content="Position Independent Code (6502) on the Commodore VIC-20">
  <meta name="twitter:description" content="If we are writing 6502 machine code and want to to create a routine or program that can be placed in any location then we have to create Position Independent Cod">
    <meta name="twitter:image"
         content="https://techtinkering.com/img/social_images/6502_pic_make_data_table_assembly.png">
  <!-- *** Twitter Card *** -->

  <!-- *** Open Graph *** --->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Position Independent Code (6502) on the Commodore VIC-20">
  <meta property="og:description" content="If we are writing 6502 machine code and want to to create a routine or program that can be placed in any location then we have to create Position Independent Cod">
  <meta property="og:url" content="https://techtinkering.com/articles/position-independent-code-6502-on-the-commodore-vic-20/">
    <meta property="og:image"
         content="https://techtinkering.com/img/social_images/6502_pic_make_data_table_assembly.png">
  <!-- *** Open Graph *** --->

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-4388762-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-4388762-2');
  </script>

  <link href="/css/prism.css" rel="stylesheet">
  <link href="/css/main.css" rel="stylesheet">
  <link href="/css/extra.css" rel="stylesheet">
  <link href="/css/article.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" rel="stylesheet" type="text/css" />
  <link rel="canonical" href="https://techtinkering.com/articles/position-independent-code-6502-on-the-commodore-vic-20/">
  <link rel="alternate" type="application/rss+xml" title="TechTinkering - Retro Computers, Programming, General Technical Tinkering"
        href="http://feedproxy.google.com/TechTinkering" />

	<!-- ****** faviconit.com favicons ****** -->
	<link rel="shortcut icon" href="/favicon.ico">
	<link rel="icon" sizes="16x16 32x32 64x64" href="/favicon.ico">
	<!-- ****** faviconit.com favicons ****** -->

  <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">

  <script src="/js/prism.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->

  <script>
    // Cookie Consent - https://cookieconsent.insites.com
    window.addEventListener("load", function(){
    window.cookieconsent.initialise({
      "palette": {
        "popup": {
          "background": "#252e39"
        },
        "button": {
          "background": "#14a7d0"
        }
      },
      "theme": "classic",
      "position": "top",
      "static": true,
      "content": {
        "message": "TechTinkering uses cookies for advertising, analytics, etc.",
        "href": "http://techtinkering.com/privacy/"
      }
    })});
  </script>

  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
         google_ad_client: "ca-pub-1613732348909658",
         enable_page_level_ads: true
    });
  </script>
</head>
  <body>
    <nav>
  <div class="container">
    <div class="navbar-header">
      <a href="/">TechTinkering</a><br />
      =============
    </div>

    <div class="contact">
      <ul>
        <li>
          <a href="http://twitter.com/TechTinkering" title="@TechTinkering on Twitter">Twitter</a>
        </li>
        <li>
          <a href="http://youtube.com/techtinkering" title="TechTinkering's YouTube Channel">YouTube</a>
        </li>
        <li>
          <a href="mailto:techtinkering@vlifesystems.com" title="Email us, we'd love to hear from you">Email</a>
        </li>
        <li>
          <a href="https://github.com/lawrencewoodman/techtinkering.com" title="Fork TechTinkering On GitHub ">GitHub</a>
        </li>
        <li>
          <a href="http://feeds.feedburner.com/TechTinkering" title="Subscribe to our RSS Feed">RSS</a>
        </li>
      </ul>
    </div>
  </div>
</nav>
    <div id="content" class="container">
      <div class="margin-buffer">
    <article itemscope itemtype="http://schema.org/BlogPosting">
    <meta itemprop="image"
         content="https://techtinkering.com/img/social_images/6502_pic_make_data_table_assembly.png" />
      <header>
        <a href="/articles/position-independent-code-6502-on-the-commodore-vic-20/" title="Position Independent Code (6502) on the Commodore VIC-20">
          <h1 itemprop="headline name">Position Independent Code (6502) on the Commodore VIC-20</h1>
        </a>
        <div>
            <time itemprop="datePublished"
                  datetime="2020-02-04">
               4 February 2020
            </time>
          <span itemscope itemprop="publisher"
                itemtype="http://schema.org/Organization">
            <meta itemprop="name" content="TechTinkering" />
            <meta itemprop="url" content="https://techtinkering.com" />
          </span>
          <span itemscope itemprop="author" itemtype="http://schema.org/Person">
            <a rel="author" itemprop="url" href="https://lawrencewoodman.github.io">
              <span itemprop="name">Lawrence Woodman</span>
            </a>
          </span>

          <ul class="tags">
              <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
              <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
              <li>#<a href="/articles/tag/programming/">Programming</a></li>
              <li>#<a href="/articles/tag/retro/">Retro</a></li>
              <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
          </ul>
        </div>
      </header>
        <div itemprop="articleBody">
        <p>If we are writing 6502 machine code and want to to create a routine or program that can be placed in any location then we have to create <em>Position Independent Code (PIC)</em> or make the code relocatable.  Here I'm going to show how to make our code  <em>Position Independent</em>.  There are three full examples near the end of the article which show how to put this altogether.</p>
<h2>Branches Instead of Jumps</h2>
<p>One of the first things we can do is use branches instead of <code>JMP</code> to an absolute address where possible.  This is because branches jump to a relative address that will still be the same if the code moves.  A branch allows a relative jump to an address -127/+128 bytes from the current address.</p>
<p>To do something similar to a <code>BRA</code> (BRanch Always) we just need to force the condition before using one of the Branch instructions.  An easy one to use is <code>BVC</code> (Branch on oVerflow Clear) as the <em>oVerflow</em> flag is only altered by the <code>ADC</code>, <code>BIT</code>, <code>CLV</code> and <code>SBC</code> instructions which makes it easy to keep track of.</p>
<p>The following absolute jump:</p>
<pre><code class="language-asm6502">            jmp label          ; 3 bytes, 3 cycles
            ...
            ...
label       nop
</code></pre>
<p>can easily be turned into a relative jump:</p>
<pre><code class="language-asm6502">            clv                ; 1 byte,  2 cycles
            bvc label          ; 2 bytes, 3-4 cycles (depending on page cross)
            ...
            ...
label       nop
</code></pre>
<p>Both jumps take 3 bytes of code, but we can see that the relative jump takes 2-3 more cycles to complete and therefore this is something to keep an eye on.  If you are sure that the <em>oVerflow</em> flag is clear then you can omit the <code>CLV</code> and actually save 1 byte and only take 0-1 more cycles to complete.</p>
<h2>Indirect Jumps for Long Jumps</h2>
<p>If the location we want to jump to is going to be further than -127/+128 bytes away then we can put the location we want to jump to in fixed memory address and then jump to that location indirectly.  We may want to do this using a data table as described further down the article.</p>
<p>To compare, here is an absolute <code>JMP</code></p>
<pre><code class="language-asm6502">            jmp labelA                ; 3 bytes, 3 cycles
</code></pre>
<p>Here is an indirect <code>JMP</code> using a data table with ILABELA as an index.  We can see that there is a 2 cycle overhead per <code>JMP</code>.</p>
<pre><code class="language-asm6502">            jmp (DATA_TABLE+ILABELA)  ; 3 bytes, 5 cycles
</code></pre>
<h2>A Data Table to Access Memory Indirectly</h2>
<p>To access memory locations that would move with the code we can create a data table in a static location that contains pointers to each location in the code.  This would be accessed via an index using indirect addressing.</p>
<p>Here is a '<em>Hello, World!</em>' routine that uses a static location for <code>helloMsg</code> which we will convert in the second piece of code to become <em>Position Independent</em> by using a data table.</p>
<pre><code class="language-asm6502">CCHROUT    = $FFD2             ; Output character to current output device

helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0

            ; Non position independent
SayHello    .(
            ; Output message
            ldy #$00
loop        lda helloMsg, y               ; 3 bytes, 4-5 cycles (depending on page cross)
            beq finished
            jsr CCHROUT                   ; Output char to screen
            iny
            bne loop
finished    rts
.)
</code></pre>
<br />
<p>The following <em>Hello World</em> routine adapts the one above and makes it <em>Position Independent</em> by looking up the address of <code>helloMsg</code> in <code>DATA_TABLE</code> using <code>IHELLOMSG</code> as an index and storing it in <code>TMP_DPTR</code>.  <code>TMP_DPTR</code> is then accessed using indirect addressing by <code>LDA</code>.  <code>DATA_TABLE</code> is located in the cassette buffer at <code>$0334</code>.</p>
<pre><code class="language-asm6502">CHR_RTN    = $0D               ; Return character
CCHROUT    = $FFD2             ; Output character to current output device
TMP_DPTR   = $FB               ; Temporary data pointer
DATA_TABLE = $0334             ; The location of the data table
IHELLOMSG  = 0                 ; Index to 'HELLO, WORLD!' message

helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0

            ; Position Independent
SayHello    .(
            ; Point TMP_DPTR to helloMsg
            lda DATA_TABLE+IHELLOMSG      ; 3 bytes, 4 cycles
            sta TMP_DPTR                  ; 2 bytes, 3 cycles
            lda DATA_TABLE+IHELLOMSG+1    ; 3 bytes, 4 cycles
            sta TMP_DPTR+1                ; 2 bytes, 3 cycles

            ; Output message
            ldy #$00
loop        lda (TMP_DPTR), y             ; 2 bytes, 5-6 cycles (depending on page cross)
            beq finished
            jsr CCHROUT                   ; Output char to screen
            iny
            bne loop
finished    rts
.)
</code></pre>
<p>If we compare the two routines we can see that there is an 8 byte overhead for the <em>PIC</em> using a data table and a 15 cycle overhead.  This is in addition to the overhead of creating the data table in the first place.</p>
<h2>A Jump Table for Subroutine Calls</h2>
<p>The <code>JSR</code> (Jump to Subroutine) instruction can only jump to absolute addresses.  One easy way to overcome this is to use a jump table.  This will contain a series of jumps to the correct location for each subroutine.</p>
<p>The jump table would contain code such as the following:</p>
<pre><code class="language-asm6502">CPRINTSCORE   jmp  $1420
CPRINTLIVES   jmp  $1430
CSHIPLEFT     jmp  $1440
CSHIPRIGHT    jmp  $1460
</code></pre>
<p>Then all the <em>PIC</em> would do is <code>JSR</code> to one of the locations in the jump table which would then jump to the location of the subroutine.  E.g. if a game contained <em>PIC</em> that wanted to move the ship left it would run the following:</p>
<pre><code class="language-asm6502">              jsr CSHIPLEFT
</code></pre>
<p>The jump table would have to be placed in a static location unless self-modifying code is used.  One possible location for the jump table could be at <em>$02A1-02FF</em> which is reserved for program indirects.  This would be enough room for a jump table containing 31 jumps.</p>
<p>The extra <code>JMP</code> instruction adds a 3 cycle overhead to every <code>JSR</code> instruction. This is in addition to the overhead of creating the jump table in the first place.</p>
<h2>Getting the Program Counter</h2>
<p>There are few situations where we would need to get the Program Counter because we could just get the address of the start of the code from the loader.  However, in case a situation arises or just for curiosity we can get the address of the <em>Program Counter</em> with the code that follows.  This code should be copied to a static address, such as the cassette buffer, and <code>JSR</code> should call it to put the address of the calling <code>JSR</code> in <code>PC</code>.</p>
<pre><code class="language-asm6502">PC        = $09                ; Location to store PC in

            ; Put address of calling JSR into PC
GetPC       .(
            pla
            sta PC             ; Store the 16-bit program counter at PC
            pla
            sta PC+1
            pha                ; Restore the return address to the stack
            lda PC
            pha
            bne decL1          ; Decrement PC by 2 to point to calling instruction
            dec PC+1
decL1       dec PC
            bne decL2
            dec PC+1
decL2       dec PC
            rts
.)
</code></pre>
<p>This works because <code>JSR</code> puts the PC+2 onto the stack and <code>RTS</code> takes two bytes from the stack, increments them and jumps to this address.</p>
<h2>Calculating Absolute Addresses</h2>
<p>To access data and run subroutines we need to calculate absolute addresses for them.  This can be done by using offsets from a certain point in the code and adding them to that point once its absolute addresses has been determined.  The absolute address of our reference point could be supplied by the machine code loader or sought using the <code>GetPC</code> routine above.</p>
<p>The following code shows how the absolute address used in a data table could be calculated to refer to a region of memory containing a <em>Hello, World</em> message.</p>
<pre><code class="language-asm6502">CHR_RTN    = $0D               ; Return character

PC         = $09               ; Location to store PC in
DATA_TABLE = $0334             ; The location of the data table
IHELLOMSG  = 0                 ; Index to 'HELLO, WORLD!' message

            * = $1001

start       jsr GetPC          ; Put absolute address of start in PC

            ; BRanch Always
            clv
            bvc makeDTable

helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0

            ; Make data table
makeDTable  clc
            lda PC
            adc #&lt;(helloMsg-start)      ; LSB of offset from start
            sta DATA_TABLE+IHELLOMSG
            lda PC+1
            adc #&gt;(helloMsg-start)      ; MSB of offset from start
            sta DATA_TABLE+IHELLOMSG+1
</code></pre>
<h2>Self-Modifying Code</h2>
<p>We can avoid the use of jump tables and data tables by using self-modifying code.  This can create quicker, smaller and more readable code, but it isn't possible to do this if the code is located in ROM.</p>
<p>To create self-modifying code we can create a table which contains address offsets to change.  The address offsets will be offset from a location in the code and at run-time the values at these addresses will be changed to absolute addresses.</p>
<pre><code class="language-asm6502">TXTTAB     = $2B               ; Pointer to start of tokenized Basic
SMADDR     = $09               ; Address to modify
PSMTABLE   = $FB               ; Pointer to self-modification table
CHR_RTN    = $0D               ; Return character


            ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
            ; Code has been removed here to create a
            ; Basic stub with first byte of stub
            ; labeled 'start'.  Where the stub is
            ; loaded can be found by looking at
            ; TXTTAB.
            ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

            ;=========================================
            ; Start of machine language
            ;=========================================
mLang
            * = mLang-start

            ; BRanch Always
            clv
            bvc setupSM

            ;-----------------------------------------
            ; Message strings
            ;-----------------------------------------
helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0
byeMsg     .asc &quot;GOODBYE, WORLD!&quot; : .byt CHR_RTN : .byt 0

            ;=========================================
            ; Self-modification
            ;=========================================

            ;-----------------------------------------
            ; Self-modification table
            ; offsetAddr
            ;-----------------------------------------
smTable     .word main+1       ; Address of SayHello routine
            .word main+4       ; Address of SayGoodbye routine
            .word SayHello+3   ; Entry within SayHello
                               ; routine pointing to helloMsg
            .word SayGoodbye+3 ; Entry within SayGoodbye
                               ; routine pointing to byeMsg
            .word 0            ; End of table

            ;-----------------------------------------
            ; Self-modify code to point to correct
            ; locations
            ;-----------------------------------------

setupSM     .(
            ; Create pointer to smTable
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;smTable
            sta PSMTABLE
            lda TXTTAB+1
            adc #&gt;smTable
            sta PSMTABLE+1

            ; Point offsets in smTable to absolute addresses
            ldy #00
            lda (PSMTABLE), y
loop       ; Calculate address to change
            clc
            adc TXTTAB
            sta SMADDR
            iny
            lda TXTTAB+1
            adc (PSMTABLE), y
            iny
            sta SMADDR+1
            ; Move value at address
            tya
            tax
            ldy #00
            clc
            lda TXTTAB
            adc (SMADDR), y
            sta (SMADDR), y
            iny
            lda TXTTAB+1
            adc (SMADDR), y
            sta (SMADDR), y
            txa
            tay
            lda (PSMTABLE), y
            bne loop           ; If not end of table
.)

            ;=========================================
            ; MAIN program
            ;=========================================
main        jsr SayHello
            jsr SayGoodbye
            rts
</code></pre>
<h2>Video Demonstrating Position Independent Code</h2>
<p>You can see <em>Position Independent Code</em> explained and run in the following video:</p>
<div class="youtube-wrapper">
<iframe width="560" height="315" src="https://www.youtube.com/embed/qil0QJO_5xo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h2>Full Examples</h2>
<p>The examples have been written for the <a href="https://www.floodgap.com/retrotech/xa/">XA</a> assembler and are hosted on GitHub: <a href="https://github.com/lawrencewoodman/position_independent_code_vic20">position_independent_code_vic20</a>.</p>
<h3>Position Independent Code Without Self-Modification</h3>
<p>The code below demonstrates creating a jump and data table to point to the subroutines and their associated message data.  The code contains a <a href="/articles/adding-basic-stubs-to-assembly-language-on-the-commodore-vic-20/" title="Adding Basic Stubs to Assembly Language on the Commodore VIC-20">Basic stub</a> to make the code easier to load and test.  It relies on location <em>$2B/$2C</em> (<code>TXTAB</code>) pointing to the start of tokenized Basic so that it can use this as a reference point to calculate the absolute addresses in the rest of the code.  The start of tokenized Basic will change depending on the memory configuration of the Vic, but the machine language code will work regardless because it is <em>Position Independent</em>.</p>
<pre><code class="language-asm6502">; Basic Stub
OPEN_PR    = $28               ; ( character
CLOSE_PR   = $29               ; ) character
PLUS       = $AA               ; + character
TIMES      = $AC               ; * character
TOK_PEEK   = $C2               ; PEEK token
TOK_SYS    = $9E               ; SYS token

CHR_RTN    = $0D               ; Return character
OP_JMPA    = $4C               ; JMP absolute opcode
TXTTAB     = $2B               ; Pointer to start of tokenized Basic
CCHROUT    = $FFD2             ; Output character to current output device

TMP_DPTR   = $FB               ; Temporary data pointer
JMP_TABLE  = $02A1             ; The location of the jump table
DATA_TABLE = $0334             ; The location of the data table
IHELLOMSG  = 0                 ; Index to 'HELLO, WORLD!' message
IBYEMSG    = IHELLOMSG+2       ; Index to 'GOODBYE, WORLD!' message
CSAYHELLO  = JMP_TABLE         ; Vector to SayHello
CSAYBYE    = JMP_TABLE+3       ; Vector to SayGoodbye


            .byt $01, $80      ; Load Address.  Using character ROM because
                               ; correct RAM location memory configuration
                               ; dependent


            ;=========================================
            ;  Basic Stub
            ;=========================================

            ; 2020 SYS PEEK(43)+PEEK(44)*256+27
            * = $1001
start       .word basicEnd     ; Next Line link, here end of Basic program
            .word 2020         ; The line number for the SYS statement
            .byt  TOK_SYS      ; SYS token
            .asc  &quot; &quot;
            .byt  TOK_PEEK     ; PEEK token
            .byt  OPEN_PR      ; (
            .asc  &quot;43&quot;         ; 43
            .byt  CLOSE_PR     ; )
            .byt  PLUS         ; +
            .byt  TOK_PEEK     ; PEEK token
            .byt  OPEN_PR      ; (
            .asc  &quot;44&quot;         ; 44
            .byt  CLOSE_PR     ; )
            .byt  TIMES        ; *
            .asc  &quot;256&quot;        ; 256
            .byt  PLUS         ; +
            .asc  &quot;27&quot;         ; 27 (The size of the stub)
            .byt  0            ; End of Basic line
basicEnd    .word 0            ; End of Basic program


            ;=========================================
            ; Start of machine language
            ;=========================================

            ; BRanch Always
            clv
            bvc makeJTable

            ;-----------------------------------------
            ; Message strings
            ;-----------------------------------------
helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0
byeMsg     .asc &quot;GOODBYE, WORLD!&quot; : .byt CHR_RTN : .byt 0


            ;=========================================
            ; Create jump and data tables
            ;=========================================

            ;-----------------------------------------
            ; Create jump table
            ;-----------------------------------------

            ; Store JMP absolute opcodes
makeJTable  lda #OP_JMPA       ; JMP absolute opcode
            sta CSAYHELLO
            sta CSAYBYE

            ; Jump table address for SayHello
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;(SayHello-start)
            sta CSAYHELLO+1
            lda TXTTAB+1
            adc #&gt;(SayHello-start)
            sta CSAYHELLO+2

            ; Jump table address for SayGoodbye
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;(SayGoodbye-start)
            sta CSAYBYE+1
            lda TXTTAB+1
            adc #&gt;(SayGoodbye-start)
            sta CSAYBYE+2

            ;-----------------------------------------
            ; Create data table
            ;-----------------------------------------

            ; Point entry at index IHELLOMSG to helloMsg
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;(helloMsg-start)
            sta DATA_TABLE+IHELLOMSG
            lda TXTTAB+1
            adc #&gt;(helloMsg-start)
            sta DATA_TABLE+IHELLOMSG+1

            ; Point entry at index IBYEMSG to byeMsg
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;(byeMsg-start)
            sta DATA_TABLE+IBYEMSG
            lda TXTTAB+1
            adc #&gt;(byeMsg-start)
            sta DATA_TABLE+IBYEMSG+1


            ;=========================================
            ; MAIN program
            ;=========================================
            jsr CSAYHELLO
            jsr CSAYBYE
            rts


            ;=========================================
            ; Subroutines
            ;=========================================

            ;-----------------------------------------
            ; SayHello
            ; Displays 'HELLO, WORLD!' message
            ;-----------------------------------------
SayHello    .(
            ; Point TMP_DPTR to helloMsg
            lda DATA_TABLE+IHELLOMSG
            sta TMP_DPTR
            lda DATA_TABLE+IHELLOMSG+1
            sta TMP_DPTR+1

            ; Output message
            ldy #$00
loop        lda (TMP_DPTR), y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)

            ;-----------------------------------------
            ; SayGoodbye
            ; Displays 'GOODBYE, WORLD!' message
            ;-----------------------------------------
SayGoodbye  .(
            ; Point TMP_DPTR to byeMsg
            lda DATA_TABLE+IBYEMSG
            sta TMP_DPTR
            lda DATA_TABLE+IBYEMSG+1
            sta TMP_DPTR+1

            ; Output message
            ldy #$00
loop        lda (TMP_DPTR), y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)
</code></pre>
<h3>Position Independent Code Using Self-Modification</h3>
<p>This example also uses a <a href="/articles/adding-basic-stubs-to-assembly-language-on-the-commodore-vic-20/" title="Adding Basic Stubs to Assembly Language on the Commodore VIC-20">Basic stub</a> and the <code>TXTTAB</code> location mentioned in the previous example.  We can see that the code below is shorter, easier to read and would run faster once the self-modification had been completed.  However, self modifying code can't be placed in ROM.</p>
<pre><code class="language-asm6502">; Basic Stub
OPEN_PR    = $28               ; ( character
CLOSE_PR   = $29               ; ) character
PLUS       = $AA               ; + character
TIMES      = $AC               ; * character
TOK_PEEK   = $C2               ; PEEK token
TOK_SYS    = $9E               ; SYS token

; Self Modification
TXTTAB     = $2B               ; Pointer to start of tokenized Basic
SMADDR     = $09               ; Address to modify
PSMTABLE   = $FB               ; Pointer to self-modification table

; Character output
CHR_RTN    = $0D               ; Return character
CCHROUT    = $FFD2             ; Output character to current output device


            .byt $01, $80      ; Load Address.  Using character ROM because
                               ; correct RAM location memory configuration
                               ; dependent


            ;=========================================
            ;  Basic Stub
            ;=========================================
            * = $1001

            ; 2020 SYS PEEK(43)+PEEK(44)*256+27
start       .word basicEnd     ; Next Line link, here end of Basic program
            .word 2020         ; The line number for the SYS statement
            .byt  TOK_SYS      ; SYS token
            .asc  &quot; &quot;
            .byt  TOK_PEEK     ; PEEK token
            .byt  OPEN_PR      ; (
            .asc  &quot;43&quot;         ; 43
            .byt  CLOSE_PR     ; )
            .byt  PLUS         ; +
            .byt  TOK_PEEK     ; PEEK token
            .byt  OPEN_PR      ; (
            .asc  &quot;44&quot;         ; 44
            .byt  CLOSE_PR     ; )
            .byt  TIMES        ; *
            .asc  &quot;256&quot;        ; 256
            .byt  PLUS         ; +
            .asc  &quot;27&quot;         ; 27 (The size of the stub)
            .byt  0            ; End of Basic line
basicEnd    .word 0            ; End of Basic program


            ;=========================================
            ; Start of machine language
            ;=========================================
mLang
            * = mLang-start

            ; BRanch Always
            clv
            bvc setupSM

            ;-----------------------------------------
            ; Message strings
            ;-----------------------------------------
helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0
byeMsg     .asc &quot;GOODBYE, WORLD!&quot; : .byt CHR_RTN : .byt 0


            ;=========================================
            ; Self-modification
            ;=========================================

            ;-----------------------------------------
            ; Self-modification table
            ; offsetAddr
            ;-----------------------------------------
smTable     .word main+1
            .word main+4
            .word SayHello+3
            .word SayGoodbye+3
            .word 0            ; End of table

            ;-----------------------------------------
            ; Self-modify code to point to correct
            ; locations
            ;-----------------------------------------

setupSM     .(
            ; Create pointer to smTable
            clc
            lda TXTTAB         ; Get start of tokenized Basic
            adc #&lt;smTable
            sta PSMTABLE
            lda TXTTAB+1
            adc #&gt;smTable
            sta PSMTABLE+1

            ; Skip self-modication if has already been run
            ; This isn't needed if sure code will only be run once
            ldy #01
            lda (PSMTABLE), y
            cmp #$FF           ; Page $FF indicates SM already run
            beq main

            ; Point offsets in smTable to absolute addresses
            ldy #00
            lda (PSMTABLE), y
loop       ; Calculate address to change
            clc
            adc TXTTAB
            sta SMADDR
            iny
            lda TXTTAB+1
            adc (PSMTABLE), y
            iny
            sta SMADDR+1
            ; Move value at address
            tya
            tax
            ldy #00
            clc
            lda TXTTAB
            adc (SMADDR), y
            sta (SMADDR), y
            iny
            lda TXTTAB+1
            adc (SMADDR), y
            sta (SMADDR), y
            txa
            tay
            lda (PSMTABLE), y
            bne loop           ; If not end of table

            ; Record that self-modification has been run
            ; by setting page of first address to $FF
            ldy #01
            lda #$FF
            sta (PSMTABLE), y
.)

            ;=========================================
            ; MAIN program
            ;=========================================
main        jsr SayHello
            jsr SayGoodbye
            rts


            ;=========================================
            ; Subroutines
            ;=========================================

            ;-----------------------------------------
            ; SayHello
            ; Displays 'HELLO, WORLD!' message
            ;-----------------------------------------
SayHello    .(
            ; Output message
            ldy #$00
loop        lda helloMsg, y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)

            ;-----------------------------------------
            ; SayGoodbye
            ; Displays 'GOODBYE, WORLD!' message
            ;-----------------------------------------
SayGoodbye  .(
            ; Output message
            ldy #$00
loop        lda byeMsg, y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)
</code></pre>
<h3>Position Independent Code Getting Absolute Address of Point in Code</h3>
<p>The last example shows how we can determine the absolute address of a point in the code from which we can calculate offsets.  The code works by creating a routine at <em>$02A1</em> to get the Program Counter (<code>GetPC</code>).  Once an absolute address has been determined all the other addresses can be calculated in relation to that address.</p>
<p>This example doesn't use a Basic stub, but does specify address <em>$1203</em> as its load address.  This address should work for all memory configurations.  To load and run it we could use:</p>
<pre><code class="language-basic">LOAD &quot;*&quot;,8,1
SYS 4611
</code></pre>
<p>We can change the load address and as long as it's a valid area for our Vic and we <code>SYS</code> to the correct address, the code will work fine.</p>
<pre><code class="language-asm6502">; Opcodes
OP_BNE     = $D0               ; BNE
OP_DECA    = $CE               ; DEC absolute
OP_JMPA    = $4C               ; JMP absolute
OP_PHA     = $48               ; PHA
OP_PLA     = $68               ; PLA
OP_RTS     = $60               ; RTS
OP_LDAA    = $AD               ; LDA absolute
OP_STAA    = $8D               ; STA absolute

CHR_RTN    = $0D               ; Return character
CCHROUT    = $FFD2             ; Output character to current output device

PC         = $09               ; Location to store PC in
TMP_DPTR   = $FB               ; Temporary data pointer
JMP_TABLE  = $02A1             ; The location of the jump table
DATA_TABLE = $0334             ; The location of the data table
IHELLOMSG  = 0                 ; Index to 'HELLO, WORLD!' message
IBYEMSG    = IHELLOMSG+2       ; Index to 'GOODBYE, WORLD!' message
CSAYHELLO  = JMP_TABLE         ; Vector to SayHello
CSAYBYE    = JMP_TABLE+3       ; Vector to SayGoodbye

GetPC      = $02A1             ; Location of GetPC routine

            .byt $03, $12      ; Load Address.
                               ; $1203 should work for any memory configuration


            ;=========================================
            ; Static data
            ;=========================================
            * = $1203

            ; BRanch Always
            clv
            bvc start

            ;-----------------------------------------
            ; Message strings
            ;-----------------------------------------
helloMsg   .asc &quot;HELLO, WORLD!&quot; : .byt CHR_RTN : .byt 0
byeMsg     .asc &quot;GOODBYE, WORLD!&quot; : .byt CHR_RTN : .byt 0


            ;=========================================
            ; Determine Absolute address for start of
            ; code
            ;=========================================

            ;-----------------------------------------
            ;  Create GetPC at $02A1
            ;-----------------------------------------
start       lda #OP_PLA        ; PLA
            sta GetPC
            lda #OP_STAA       ; STA PC
            sta GetPC+1        ; - Store the 16-bit program counter at PC
            lda #&lt;PC           ;
            sta GetPC+2
            lda #&gt;PC
            sta GetPC+3
            lda #OP_PLA        ; PLA
            sta GetPC+4
            lda #OP_STAA       ; STA PC+1
            sta GetPC+5
            lda #&lt;PC+1
            sta GetPC+6
            lda #&gt;PC+1         ; Using MSB of PC in case moved out of zero page
            sta GetPC+7
            lda #OP_PHA        ; PHA
            sta GetPC+8        ; - Restore the return address to the stack
            lda #OP_LDAA       ; LDA PC
            sta GetPC+9
            lda #&lt;PC
            sta GetPC+10
            lda #&gt;PC
            sta GetPC+11
            lda #OP_PHA        ; PHA
            sta GetPC+12
            lda #OP_BNE        ; BNE decL1
            sta GetPC+13       ; - PC=PC-2 to point to calling instruction
            lda #$03
            sta GetPC+14
            lda #OP_DECA      ; DEC PC+1
            sta GetPC+15       ; - MSB
            lda #&lt;PC+1
            sta GetPC+16
            lda #&gt;PC+1
            sta GetPC+17
            lda #OP_DECA      ; decL1:  DEC PC
            sta GetPC+18       ; - LSB
            lda #&lt;PC
            sta GetPC+19
            lda #&gt;PC
            sta GetPC+20
            lda #OP_BNE        ; BNE decL2
            sta GetPC+21
            lda #$03
            sta GetPC+22
            lda #OP_DECA      ; DEC PC+1
            sta GetPC+23
            lda #&lt;PC+1
            sta GetPC+24
            lda #&gt;PC+1
            sta GetPC+25
            lda #OP_DECA      ; decL2:  DEC PC
            sta GetPC+26
            lda #&lt;PC
            sta GetPC+27
            lda #&gt;PC
            sta GetPC+28
            lda #OP_RTS        ; RTS
            sta GetPC+29

callGetPC   jsr GetPC          ; Get absolute address of callGetPC


            ;=========================================
            ; Create jump and data tables
            ;=========================================

            ;-----------------------------------------
            ; Create jump table
            ;-----------------------------------------

            ; Store JMP absolute opcodes
            lda #OP_JMPA       ; JMP absolute opcode
            sta CSAYHELLO
            sta CSAYBYE

            ; Jump table address for SayHello
            clc
            lda PC
            adc #&lt;(SayHello-callGetPC)
            sta CSAYHELLO+1
            lda PC+1
            adc #&gt;(SayHello-callGetPC)
            sta CSAYHELLO+2

            ; Jump table address for SayGoodbye
            clc
            lda PC
            adc #&lt;(SayGoodbye-callGetPC)
            sta CSAYBYE+1
            lda PC+1
            adc #&gt;(SayGoodbye-callGetPC)
            sta CSAYBYE+2

            ;-----------------------------------------
            ; Create data table
            ;-----------------------------------------

            ; Point entry at index IHELLOMSG to helloMsg
            clc
            lda PC
            adc #&lt;(helloMsg-callGetPC)
            sta DATA_TABLE+IHELLOMSG
            lda PC+1
            adc #&gt;(helloMsg-callGetPC)
            sta DATA_TABLE+IHELLOMSG+1

            ; Point entry at index IBYEMSG to byeMsg
            clc
            lda PC
            adc #&lt;(byeMsg-callGetPC)
            sta DATA_TABLE+IBYEMSG
            lda PC+1
            adc #&gt;(byeMsg-callGetPC)
            sta DATA_TABLE+IBYEMSG+1


            ;=========================================
            ; MAIN program
            ;=========================================
            jsr CSAYHELLO
            jsr CSAYBYE
            rts


            ;=========================================
            ; Subroutines
            ;=========================================

            ;-----------------------------------------
            ; SayHello
            ; Displays 'HELLO, WORLD!' message
            ;-----------------------------------------
SayHello    .(
            ; Point TMP_DPTR to helloMsg
            lda DATA_TABLE+IHELLOMSG
            sta TMP_DPTR
            lda DATA_TABLE+IHELLOMSG+1
            sta TMP_DPTR+1

            ; Output message
            ldy #$00
loop        lda (TMP_DPTR), y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)

            ;-----------------------------------------
            ; SayGoodbye
            ; Displays 'GOODBYE, WORLD!' message
            ;-----------------------------------------
SayGoodbye  .(
            ; Point TMP_DPTR to byeMsg
            lda DATA_TABLE+IBYEMSG
            sta TMP_DPTR
            lda DATA_TABLE+IBYEMSG+1
            sta TMP_DPTR+1

            ; Output message
            ldy #$00
loop        lda (TMP_DPTR), y
            beq finished
            jsr CCHROUT        ; Output char to screen
            iny
            bne loop
finished    rts
.)
</code></pre>
      </div>
    </article>
</div>

  <div id="cclicence">
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
      <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
    </a>
    <br />
    <span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Position Independent Code (6502) on the Commodore VIC-20</span>
    by <a xmlns:cc="http://creativecommons.org/ns#" href="https://techtinkering.com/articles/position-independent-code-6502-on-the-commodore-vic-20/" property="cc:attributionName" rel="cc:attributionURL">Lawrence Woodman</a>
   is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
   
  </div>


  <div class="discuss">
    <h2 style="margin-top:0;">Share This Post</h2>
    <div class="contact">
  <ul>
    <li><a href="http://www.reddit.com/submit?url=https%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F&title=Position%20Independent%20Code%20%286502%29%20on%20the%20Commodore%20VIC-20" target="_blank" title="Submit to Reddit">Reddit</a></li>
    <li><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F&quote=Position%20Independent%20Code%20%286502%29%20on%20the%20Commodore%20VIC-20" target="_blank" title="Share on Facebook">Facebook</a></li>
    <li><a href="https://twitter.com/intent/tweet?source=https%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F&text=Position%20Independent%20Code%20%286502%29%20on%20the%20Commodore%20VIC-20:%0Ahttps%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F&via=TechTinkering" target="_blank" title="Tweet">Twitter</a></li>
    <li><a href="mailto:?subject=Position%20Independent%20Code%20%286502%29%20on%20the%20Commodore%20VIC-20&body=If%20we%20are%20writing%206502%20machine%20code%20and%20want%20to%20to%20create%20a%20routine%20or%20program%20that%20can%20be%20placed%20in%20any%20location%20then%20we%20have%20to%20create%20Position%20Independent%20Code%20%28PIC%29%20or%20make%20the%20code%20relocatable.%20%20H...:%0A%0Ahttps%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F" target="_blank" title="Send email">Email</a></li>
  </ul>
</div>

    <h2>Feedback/Discuss</h2>
    <div class="contact">
  <ul>
      <li><a href="https://twitter.com/TechTinkering/status/1224674967348031488" target="_blank" title="Discuss on Twitter">Twitter</a></li>

    <li><a href="mailto:techtinkering@vlifesystems.com?subject=Comment:%20Position%20Independent%20Code%20%286502%29%20on%20the%20Commodore%20VIC-20&body=Article%20URL:%20https%3A%2F%2Ftechtinkering.com%2Farticles%2Fposition-independent-code-6502-on-the-commodore-vic-20%2F%0A" title="Send us an email">Email</a></li>
  </ul>
</div>
  </div>

  <div id="email-subscribe">
  <form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open('https://feedburner.google.com/fb/a/mailverify?uri=TechTinkering', 'popupwindow', 'scrollbars=yes,width=550,height=520');return true">
    <p>Sign up to get new articles straight to your inbox.</p>
    <p><input type="text" style="width:180px" name="email" placeholder="Email address"/>
    <input type="hidden" value="TechTinkering" name="uri"/>
    <input type="hidden" name="loc" value="en_US"/>
    <input class="subscribe-button" type="submit" value="Subscribe" /></p>
    <p>Delivered by <a href="https://feedburner.google.com" target="_blank">FeedBurner</a></p>
  </form>
</div>


    <div>
    <h2>Related Articles</h2>
    <div class="margin-buffer">
      <header>
  <h2><a href="/articles/subleq-on-the-commodore-vic-20/">SUBLEQ on the Commodore VIC-20</a></h2>
  <span class="post-meta">
      <time datetime="2020-07-09">
         9 July 2020
      </time>
    <ul class="tags">
      <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
      <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
      <li>#<a href="/articles/tag/oisc/">OISC</a></li>
      <li>#<a href="/articles/tag/programming/">Programming</a></li>
      <li>#<a href="/articles/tag/retro/">Retro</a></li>
      <li>#<a href="/articles/tag/subleq/">SUBLEQ</a></li>
      <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
    </ul>
  </span>
</header>
<div>
  I have created a SUBLEQ Virtual Machine for the Commodore VIC-20.  SUBLEQ is a computer architecture that has only one instruction: SUBLEQ.  The instruction stands for SUbtract and Branch if Less than ...
  &nbsp;
  <a class="readMore" href="/articles/subleq-on-the-commodore-vic-20/">Read More</a>
</div>
<br />
      <header>
  <h2><a href="/articles/sweet-16-the-6502-dream-machine-ported-to-the-vic-20/">Sweet 16 (The 6502 Dream Machine) Ported to the VIC-20</a></h2>
  <span class="post-meta">
      <time datetime="2020-02-29">
        29 February 2020
      </time>
    <ul class="tags">
      <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
      <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
      <li>#<a href="/articles/tag/programming/">Programming</a></li>
      <li>#<a href="/articles/tag/retro/">Retro</a></li>
      <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
    </ul>
  </span>
</header>
<div>
  Sweet 16 was created by Steve Wozniak to reduce code size and make it easier to handle 16-bit pointers and arithmetic for his Apple Integer BASIC.  He wrote it around 1977 and referred to it in an arti...
  &nbsp;
  <a class="readMore" href="/articles/sweet-16-the-6502-dream-machine-ported-to-the-vic-20/">Read More</a>
</div>
<br />
      <header>
  <h2><a href="/articles/adding-basic-stubs-to-assembly-language-on-the-commodore-vic-20/">Adding Basic Stubs to Assembly Language on the Commodore VIC-20</a></h2>
  <span class="post-meta">
      <time datetime="2020-01-16">
        16 January 2020
      </time>
    <ul class="tags">
      <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
      <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
      <li>#<a href="/articles/tag/programming/">Programming</a></li>
      <li>#<a href="/articles/tag/retro/">Retro</a></li>
      <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
    </ul>
  </span>
</header>
<div>
  To make machine language programs more friendly it's nice to add a Basic stub which contains a line with a SYS statement to start the code.  This is easy to do on the VIC-20 and the process gives you a...
  &nbsp;
  <a class="readMore" href="/articles/adding-basic-stubs-to-assembly-language-on-the-commodore-vic-20/">Read More</a>
</div>
<br />
      <header>
  <h2><a href="/articles/hand-assembling-to-machine-code-on-the-commodore-vic-20/">Hand Assembling to Machine Code on the Commodore VIC-20</a></h2>
  <span class="post-meta">
      <time datetime="2019-12-18">
        18 December 2019
      </time>
    <ul class="tags">
      <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
      <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
      <li>#<a href="/articles/tag/programming/">Programming</a></li>
      <li>#<a href="/articles/tag/retro/">Retro</a></li>
      <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
    </ul>
  </span>
</header>
<div>
  I quite enjoy designing machine language routines on paper and then hand assembling them.  For many people this would have been their only option until they got a more advanced machine language monitor...
  &nbsp;
  <a class="readMore" href="/articles/hand-assembling-to-machine-code-on-the-commodore-vic-20/">Read More</a>
</div>
<br />
      <header>
  <h2><a href="/2013/05/04/creating-a-tty-simulator-in-assembly-language-on-the-vic-20/">Creating a TTY Simulator in Assembly Language on the VIC-20</a></h2>
  <span class="post-meta">
      <time datetime="2013-05-04">
         4 May 2013
      </time>
    <ul class="tags">
      <li>#<a href="/articles/tag/assembly/">Assembly</a></li>
      <li>#<a href="/articles/tag/commodore/">Commodore</a></li>
      <li>#<a href="/articles/tag/programming/">Programming</a></li>
      <li>#<a href="/articles/tag/retro/">Retro</a></li>
      <li>#<a href="/articles/tag/vic-20/">VIC-20</a></li>
    </ul>
  </span>
</header>
<div>
  The Vicmon machine language cartridge is an excellent tool for exploring the Vic-20.  This article and its associated video will show you how to use it to create a simple program that will change the n...
  &nbsp;
  <a class="readMore" href="/2013/05/04/creating-a-tty-simulator-in-assembly-language-on-the-vic-20/">Read More</a>
</div>
<br />
</div>
    </div>

    </div>

    <footer>
  <nav>
    <div class="container">
      <div>
        <strong>Legal:</strong>
        <a href="/terms/">T & C</a>, <a href="/privacy/">Privacy Policy</a>
      </div>
    </div>
  </nav>
</footer>
  </body>
</html>